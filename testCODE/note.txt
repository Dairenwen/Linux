介绍了如何将vscode与host相连接，注意两者的版本问题
其中，vscode需要下载ssh有关的插件进行连接

进程间通信：
1.两个进程之间需要通信交流，进程间通信的本质，必须让不同的进程看到同一份“资源”，即一份内存空间
2.一般由操作系统来提供这一内存空间，为什么不是其中一个进程提供？会破坏独立性！
3.操作系统提供系统调用接口用于通信，这个通信模块属于文件系统，IPC通信模块（基于system V和posix标准）
4.而文件之间的通信通常使用管道：
管道的原理：
1.当父进程创建子进程时，会写时拷贝PCB，虚拟地址空间这些东西，文件描述符file_struct也会拷贝，那么文件是否会拷贝？(struct file) ，不会而是父子进程共同指向同一个文件
2.管道就是文件，需要内存，与文件性质一样，只是不刷新到磁盘中去，通信时通过读写两种方式分别打开同一个管道文件，因为打开方式不同，所以会分配两个文件描述符，创建子进程时文件描述符拷贝，file_struct拷贝，但是文件层面相同，并且指向同一块文件缓冲区，根据需要父子进程分别关闭一个读写文件，实现单向通信——管道
3.如果没有任何关系，那么不能通过这一个原理进行通信，必须有血缘关系，常用于父子
4.建立信道是必然的，成本也高昂，都是因为进程具有独立性

管道的特征：
1.具有血缘关系之间的进程进行通信
2.管道只能单向通信
3.父子进程是会进程协同的，同步与互斥——保护管道文件的数据安全
4.管道是面向字节流的
5.管道是基于文件的，如果不关闭开启的管道，最后会被操作系统释放掉

管道通信中的四种情况：
1.读写端正常，管道如果为空，读端就要阻塞
2.读写端正常，管道如果被写满，写端就要阻塞
3.读端正常读，写端关闭，读端读到0，表明读到了文件结尾，不会被阻塞
4.写端正常写，读端关闭，操作系统会通过信号杀掉写端进程


PIPE_BUF：原子写入的最大字节数，为4KB，超过这个大小可能导致数据混乱，管道的大小是64KB

介绍一下系统调用接口：
int pipe(int pipefd[2]);其中为输出型参数，pipefd[0]为读文件描述符，pipefd[1]为写文件描述符

写入已存在块的场景：
当需要修改磁盘中一个已被文件占用的数据块时，操作系统通常会遵循以下流程：
步骤 1：读取原块内容到内存
若该块数据未在内存中，系统会先从磁盘读取该块数据到页缓冲区（即物理内存的页框，对应struct page），此时页缓冲区中的页会被标记为 “干净页”（未修改时）。
步骤 2：在内存中修改数据
程序对页缓冲区中的数据进行修改，此时该页会被标记为脏页（Dirty Page）。
步骤 3：刷新脏页到磁盘
脏页会通过操作系统的刷新机制（如定期刷新、主动调用fsync等）写回磁盘原块位置，覆盖原有数据。

命名管道：
1.上面的讲的是匿名管道，即没有文件名，系统通过pipe接口分配一块内存给具有血缘关系的进程进行通信，如果是两个互不相关的进程进行通信，需要
	int mkfifo(const char *pathname, mode_t mode);接口创建命名管道，
	int unlink(const char *pathname);删除文件
2.进程间通信的本质是需要看到同一块资源，如果两个进程读写同一个文件，那么架构上与匿名管道大致相同，如何确保是打开的同一个文件，路径+文件名一致确保

设计一个日志函数:
1.日志：日志时间 日志等级 日志内容 文件的名称和行号
日志等级分为：info：常规信息
			 Warning：报警信息
			 Error：非常严重了，可能需要立即处理
			 Fatal：致命的
