缓冲区：
C中的库函数printf,fprintf,fwrite在不刷新缓冲区的前提下（不使用\n or fflush()）都会先在缓冲区保存，（这个缓冲区是C语言的缓冲区，在内核之上），
而系统调用 write函数 会写入内核缓冲区，调用 close 时，内核会强制将文件描述符对应的所有的内容从内核缓冲区刷新到磁盘，缓冲区都有多种刷新方式：

	缓冲区的刷新分为 用户缓冲区（用户空间） 和 内核缓冲区（内核空间） 两个层面，两者的刷新触发条件和机制不同。以下是具体的刷新方式分类说明：

一、用户缓冲区（用户空间）的刷新方式
	用户缓冲区由应用程序或编程语言的标准库（如 C 的 stdio）管理，用于暂存待写入内核的数据（或暂存已读取但未被应用处理的数据）。
其刷新（即数据从用户缓冲区传递到内核）的触发方式主要有以下几类：
	1. 自动刷新（标准库自动触发）
标准库会根据缓冲区类型（全缓冲、行缓冲、无缓冲）自动决定何时刷新：
	全缓冲：缓冲区填满时自动刷新。典型场景：对普通文件的写入（如 fopen 打开的文件）
	行缓冲：遇到换行符（\n）时自动刷新。典型场景：终端输出（如 stdout）
	无缓冲：数据直接传递给内核，无缓冲。典型场景：错误输出（如 stderr）
注：C缓冲区通过write系统调用写入到内核缓冲区，进程退出的时候也会刷新user-space
	2. 手动刷新（应用程序主动触发）
应用程序可通过以下方式强制刷新用户缓冲区：
	调用 fflush 函数：显式刷新指定流的用户缓冲区。
	程序正常终止（如 exit）：调用 exit 时，标准库会遍历所有打开的流，调用 fflush 刷新用户缓冲区（_exit 不会触发此操作）。

用户缓冲区存在的意义：
	1.提高效率，操作系统的 系统调用（如 write/read）是高成本操作：每次系统调用需要进行用户态与内核态的上下文切换（Context Switch），
涉及寄存器保存、内存地址空间切换等操作，若应用程序每次写入少量数据（如 1 字节）就调用一次 write，会导致大量 CPU 资源消耗在上下文切换上，
而非实际数据处理，通过用户缓冲区暂存数据，将多次小规模写入合并为一次大规模系统调用，提到了语言效率。
	2.配合格式化，什么是格式化？格式化函数（如 C 的 printf）的核心功能是：将程序中的结构化数据（如整数、浮点数、字符串）转换为符合特定格式的字符流（如 %d → 十进制字符串，%f → 带小数点的字符串）。
	格式化操作产生或处理的是字符序列，而底层 I/O（如 write/read）只能处理原始字节流。缓冲区作为中间层，负责：
	暂存格式化后的字符序列，避免逐字符调用系统函数；
	为格式化解析提供灵活的字符操作空间（如预读、回退、按格式切割字符）。

进行重定向或者创建子进程时缓冲区发生的事：
	1.重定向到文件，缓冲区刷新方式由行刷新→全刷新，其他视情况而定
	2.创建子进程，代码数据发生写时拷贝（包括用户缓冲区），如果采用全缓冲写入到文件，最后进程结束文件中会有父子进程缓冲区的内容(*double)

