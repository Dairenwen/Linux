进程终止：
可以分为三种情况：
	1.代码运行完毕，结果正确
	2.代码运行完毕，结果不正确
	3.代码异常终止
父进程会根据子进程main函数的退出码（return的返回值）来判断代码的运行情况：
	1.返回码为0，对应情况1，运行成功；
	2.返回码不为0，不同的数字对应不同的情况；

查看最近一次的退出码：echo $?
知道了退出码，退出码和退出码的描述具有对应关系，再通过strerror来将错误打印出来。在C语言中，有errno这样的全局变量来保存最近一次的错误吗，可以用perror/strerror来打印错误信息。

exit()中的参数就是当前进程的错误码，但是与return 错误码不同的是可以表示进程退出，并且冲刷缓冲区（在进程地址空间4GB中的3GB用户区），而return只有在main函数中才表示进程退出，其他地方表示函数结束；_exit()是系统调用，直接通过内核退出进程，不会冲刷缓冲区。

	3.进程异常，代码没有跑完，返回的退出码无意义，本质上是进程收到了一个信号，eg：kill -8 …/kill -18 …收到信号后进程异常终止。

进程等待：
1.为什么要进程进程等待？子进程退出，父进程没有处理，就会造成内存泄露，进程等待就是来解决内存泄漏的，且僵尸进程不能被杀死，只能通过进程等待的方式解决
2.进程等待是什么?通过系统调用wait/waitpid，来对子进程状态进程检测与回收的功能
3.回收单个子进程，wait返回创建子进程后的返回值，但如果子进程不退出，wait不返回，默认叫做阻塞状态；如果回收多个子进程，将wait的返回值多次接收。也可以使用waitpid，第一个参数设为-1等待任意子进程，设为id等待指定子进程，第二个参数是一个整形，传递地址作为输出型参数：
	整形分为32位，0000 0000 0000 0000 0000 0000 0000 0000，前16位不考虑，后十六位进行写入标记；
	0000 0000 |0|000 0000后八位表示异常码，第八位标识core dump，前八位表示退出码，自己想要查看两码可以进程位操作，也可以用宏：
	WIFEXITED(status): 若为正常终止子进程返回的状态，则为真
	WEXITSTATUS(status): 若WIFEXITED非零，提取子进程退出码
第三个参数是阻塞方式，如果选择WNOHANG则代表非阻塞轮询，其核心特点是：调用后立即返回结果，若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回该子进程的ID，其他则代表阻塞状态，
· 如果子进程已经退出，调用wait/waitpid时，wait/waitpid会立即返回，并且释放资源，获得子进程退
出信息，返回值>0
· 如果在任意时刻调用wait/waitpid，子进程存在且正常运行，则进程可能阻塞，返回值=0
· 如果不存在该子进程，则立即出错返回，返回值<0
